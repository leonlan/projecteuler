#+PROPERTY: header-args :tangle yes :exports both

* Project Euler

** Solved problems

*** Problem 69: Totient maximum
Can be solved analytically. Otherwise, use a totient sieve.

*** Problem 70: Totient permutation
Use a totient sieve to solve this problem.

*** Problem 74: Digit factorial chains
This type of problem is solved using a cache, which keeps track of intermediate results. Without a cache, brute-forcing would be ridiculously expensive.

*** Problem 92: Square digit chains
This type of problem is best solved using a cache.b

*** [[https://projecteuler.net/problem=183][Problem 183: Maximum product of parts]] :optimization:
This question has bothered me for quite a long time. When I looked at this problem for the first time, I thought it would be a simple convex optimization problem which I could solve using =cvxpy= or some other convex solver. However, not realizing that I could rewrite the optimization problem, I became stuck and never managed to do this.

Then I realized that $(N/k)^k$ is an *unconstrained optimization problem* and might actually be differentiable, although it was not so obvious how to. I looked up on how to differentiate any function in the form of $x^x$ and landed upon the topic of [[http://mathcentral.uregina.ca/QQ/database/QQ.09.03/cher1.html][implicit differentiation]]. Using the techniques outlined there, I computed that $k^* = \frac{N}{e}$ is the maximizer. However, we cannot use non-integer valued solutions, so we need to round $k$. Using the code below I empirically tested that rounding to the nearest integer is always best.

#+BEGIN_SRC python :results output :session p183
from math import exp

def P(r, k):
    return r**k

def optimize(N):
    """Finds k such that P(N, k) is maximized."""
    best_k, best_P = 0, 0
    for k in range(2, N):
        r = N/k
#        print(k, r, P(r, k))
        if P(r, k) >= best_P:
            best_P = P(r, k)
            best_k = k
    return best_k, round(N*exp(-1)), best_P

def brute_force(d=15):
    """Iterate over the first 15 problems."""
    print("Best k (bruteforce), best k (using N/e), best P (bruteforce)")
    for i in range(5, d):
        print(optimize(i))

brute_force()
#+END_SRC

#+RESULTS:
#+begin_example
Best k (bruteforce), best k (using N/e), best P (bruteforce)
(2, 2, 6.25)
(2, 2, 9.0)
(3, 3, 12.703703703703706)
(3, 3, 18.96296296296296)
(3, 3, 27.0)
(4, 4, 39.0625)
(4, 4, 57.19140625)
(4, 4, 81.0)
(5, 5, 118.81376000000002)
(5, 5, 172.10367999999994)
#+end_example

So that makes finding the optimal $k$ an easy job. However, how do we decide that $M(N)$ is a terminating decimal or not? Googling brought me to the following [[https://magoosh.com/gmat/math/basics/gmat-math-terminating-and-repeating-decimals/#:~:text=expression%20will%20terminate.-,If%20the%20prime%20factorization%20of%20the%20denominator%20of%20a%20fraction,then%20the%20decimal%20expression%20repeats.][theorem]]:

#+BEGIN_SRC
If the prime factorization of the denominator of a fraction has only factors of 2 and factors of 5, the decimal expression terminates.  If there is any prime factor in the denominator other than 2 or 5, then the decimal expression repeats.
#+END_SRC

That's pretty easy to check! Also, we just need to check this fact for $N/k^*$, since putting a power on it just changes the multiplicity of existing prime factors. Below I wrote an example for the =is_terminating= function.

#+BEGIN_SRC python :results output :session p183
from sympy import factorint
from collections import defaultdict

def is_terminating(n, d):
    """Checks if the fraction n/d is terminating or not."""
    fn = defaultdict(int, factorint(n))
    fd = defaultdict(int, factorint(d))

    # Cancel terms which occur both in fn and fd
    for k, v in fn.items():
        c = min(fn[k], fd[k])
        fn[k] -= c
        fd[k] -= c

    # Check if denominator only contains 2s and 5s
    for k, v in fd.items():
        if k not in [2, 5]:
            if v > 0:
                return False
    return True

# Example from the problem statement
print(is_terminating(14641, 256))
#+END_SRC

#+RESULTS:
: True
*** [[https://projecteuler.net/problem=197][Problem 197: Investigating the behaviour of a recursively defined sequence]] :bruteforce:
Not sure what to think of this problem. I wrote the code below and did some googling, and it turns out that this sequence converges really fast, so we can just take N = 10000 and get the answer.. But I'm kind of disappointed that it's easy to compute without having to think about the math.

#+BEGIN_SRC python :results output
from math import floor, pow
import numpy as np

def f(x):
    return floor(pow(2, 30.403243784 - pow(x, 2))) * pow(10, -9)

K = 10000
u = np.zeros(K)
u[0] = -1
for i in range(1, K):
    u[i] = f(u[i-1])
print(u[i-1],u[i])

#+END_SRC

#+RESULTS:
: 1.029461839 0.681175878

From the discussion board, I read that the math is actually pretty neat.

*** [[https://projecteuler.net/problem=287][Problem 287: Quad-tree encoding (a simple compression algorithm)]] :recursion:
Let's first get a better understanding of the problem instance by visualizing the matrix for small $N$:
#+BEGIN_SRC python :results output
import numpy as np
from itertools import product


N = 3
A = np.zeros((2**N, 2**N))

def is_black(coord, N):
    x, y = coord
    return (x-2**(N-1))**2 + (y-2**(N-1))**2 <= 2**(2*N-2)

def is_white(coord, N):
    x, y = coord
    return not is_black(x, y, N)

for i, j in product(range(2**N), repeat=2):
    if is_black((i, j), N):
        A[2**N-j-1][i] = 1

print(A)
#+END_SRC

#+RESULTS:
: [[0. 0. 1. 1. 1. 1. 1. 0.]
:  [0. 1. 1. 1. 1. 1. 1. 1.]
:  [0. 1. 1. 1. 1. 1. 1. 1.]
:  [1. 1. 1. 1. 1. 1. 1. 1.]
:  [0. 1. 1. 1. 1. 1. 1. 1.]
:  [0. 1. 1. 1. 1. 1. 1. 1.]
:  [0. 0. 1. 1. 1. 1. 1. 0.]
:  [0. 0. 0. 0. 1. 0. 0. 0.]]

This kind of looks like a circle (of ones) in the middle. This makes our life much easier, because checking if a 'split' square is of 1 color can be done in checking the corners of the square (why?). Recursion is then feasible, because we can shortcut many subproblems and don't need to consider all $2^N$ possible subproblems.

My solution implements the following functions:
- =is_black(coord, N)= :: Checks if a given coordinate is black or not.
- =new_coords(coord, position, N)= :: Computes new coordinates for each subproblem.
- =same_color(coords, N)= :: Checks if the corners coordinates of a square all have the same color. Could be either white or black.
- =encode(coords, N, K)= :: Recursive computation of the length of the minimal encoding.

Without any optimizations, my algorithm took about 15 minutes to finish. I did some fiddling and managed to find the following optimizations to get it down to 4 minutes:
1. I sped-up =same_color= by 50% by summing the coordinate-colors (0 white, 1 black) and checking if it is either 0 (all white) or 4 (all black).
2. In =is_black=, I computed =2**(2N-2)= in every function call, but this is really expensive considering that this would be done for all coordinates. Instead, pre-computing this value decreased the speed by 33%.
3. In fact, using =math.pow= is much more efficient than =**= for some reason. This also increased my algorithm by about 50%.
4. In the discussion board people also talked about a symmetry (top left is rotational symmetric to right bottom) which could also speed up the code by 25%. I did not implement this.

As mentioned on the discussion board, it should be possible to get a pure python code to run in under 1 minute but it will require more optimizations. More specifically, computing =is_black= could be optimized much further (for example, a pre-computed table for (x, y) values for which the coordinates are guaranteed to be black).

*** [[https://projecteuler.net/problem=265][Problem 265: Binary circles]] :recursion:
Problem understanding
- Start with [0]*N.
- What are the possible binary circle representations?
- Each subsequence in 2*N must appear exactly once.

If I extend my current substring, then I can only append 0 or 1. That means that the total possible number of substrings I can make is O(2^(2^N)). Luckily, we don't need to compute them all. Here is a code that I wrote really quick:

#+BEGIN_SRC python :results output
def is_substring(s, substring):
    return substring in s

def check(s, N):
    S = set()
    s = s + s[:N-1]
    return len(set([s[i:i+N] for i in range(2**N)])) == 2**N

L = []

def extend(seq, tail, N):
    if len(seq) == 2**N:
        if check(seq, N):
            L.append(seq)
    else:
        for i in range(2):
            candidate = tail[1:] + f'{i}'
            if not is_substring(seq, candidate):
                extend(seq + f'{i}', candidate, N)

extend('000', '000', 3)
print(L)
#+end_src

#+RESULTS:
: ['00010111', '00011101']

Surprisingly, it turns out that this also works fine for $N=5$. It even terminates within 1 second. The =check= procedure might be a bit expensive, but there aren't many 32-bit candidates that we need to check, so it is not a big issue.
** Work in progress

*** [[https://projecteuler.net/problem=300][Problem 300: Protein folding]]
Problem:
- Suppose you have a random H-P string of size 2**N
- What is the expected number of H-H contact points?

Thoughts
- 0 H => 0 points
- 1 H => 0 points
- 2 H => 1 point or 0 point
  For example, HPH can never have a point connected.
  But HHP can always get a point connected

Steps:
- Suppose
- Find the optimal string(s)
- Compute all possibilities of H/P element placements
- Calculate the H-H contact points, sum them up

**** TODO How many optimal foldings exist?

**** TODO

*** [[https://projecteuler.net/problem=166][Problem 165: Intersections]]
Sketch:
- Given (x1, y1) and (x2, y2), compute f(x) = ax + bx
- True intersection point if any endpoint is not a solution to f(x)

*** [[https://projecteuler.net/problem=166][Problem 166: Criss Cross]]
From left to right, top to bottom, define the variables $x_{i}$ for $i=1, \dots, 16$ as the value at position $i$. We can then setup a system of linear equations:
\begin{align*}
x_{1}+x_{2}+x_{3}+x_{4} = d \\
x_{5}+x_{6}+x_{7}+x_{8} = d \\
x_{9}+x_{10}+x_{11}+x_{12} = d \\
x_{13}+x_{14}+x_{15}+x_{16} = d \\
x_{1}+x_{5}+x_{9}+x_{13}=d \\
x_{2}+x_{6}+x_{10}+x_{14}=d \\
x_{3}+x_{7}+x_{11}+x_{15}=d \\
x_{4}+x_{8}+x_{12}+x_{16}=d \\
x_{1}+x_{6}+x_{11}+x_{16}=d \\
x_{4}+x_{7}+x_{10}+x_{13}=d \\
\end{align*}

Ten equations with 16 variables; 6 of those variables will be free. Simplifying all those equations will yield:

....

*** [[https://projecteuler.net/problem=285][Problem 285: Pythagorean odds]]
#+BEGIN_SRC python :results output
from random import random
from math import sqrt

def draw(k):
    a = random()
    b = random()
    if round(sqrt((k*a+1)**2 + (k*b+1)**2)) == k:
        return k
    else:
        return 0

def play(K):
    score = 0
    for k in range(1, K+1):
        score += draw(k)
    return score

def simulation(k, iterations=100000):
    total = 0
    for i in range(iterations):
        total += play(k)
    return total/iterations

print(simulation(10))

#+END_SRC

#+RESULTS:
: 10.21561

*** [[https://projecteuler.net/problem=333][Problem 333: Special partitions]] :bruteforce:
My most important observations are:
- There are not so many numbers below $N$ that can be expressed *only* as $2^i*3^j$. So we might want to pre-compute all these numbers. We call such numbers *partition numbers*.
- Given two partition numbers $x$ and $y$, when do they divide each other? By the unique prime factorization theorem, we know $x | y$ if both exponents of $x$ are less or equal element-wise than the exponents of $y$. To give an example: $1=2^0x3^0$ divides $16=2^4x3^0$ because $0 \leq 4$ and $0 \leq 0$. We call $x$ and $y$ *neighbors* if $x$ divides $y$ or $y$ divides $x$.

With this, we can simply create a tree for each $p$ to brute-force all possible legible sets of partition numbers.

<2020-11-11 Wed> The case for n = 100 is solved, but it takes way too long to solve n = 10^6. In my current estimates, it would take about 17 hours. Not sure why it would take so long..
- How can we skip some prime numbers?


#+BEGIN_SRC python :results output
from collections import defaultdict
from sympy import sieve
threshold = 1000000

# This should give me all legitimate partitioning numbers
L = []
for i in range(30):
    for j in range(20):
        x = 2**i*3**j
        if x <= threshold:
            L.append([x, i, j])

L = sorted(L[1:])

# Which numbers can be put together?
# Def: neighbors
neighbors = defaultdict(list)
for (n, i, j) in L:
    for (m, x, y) in L:
        if i <= x and j <= y or x <= i and y <= j:
            pass
        else:
            neighbors[n].append(m)

# For certain p, recursively check if I can make it.
def intersection(L1, L2):
    return [x for x in L1 if x in L2]


def P(q):
    total = 0
    def partition(p, last, candidates):
        if p == 0:
            nonlocal total
            total += 1
        elif candidates:
            for n in candidates:
                if last >= n and p >= n:
                    new_candidates = intersection(candidates, neighbors[n])
                    partition(p-n, n, new_candidates)
        else:
            pass
    for (x, i, j) in L:
        if x <= q:
            partition(q-x, x, neighbors[x])
    return total
print(sum([q for q in sieve.primerange(2, 100) if P(q) == 1]))


#+END_SRC

#+RESULTS:
: 233

***

*** [[https://projecteuler.net/problem=336][Problem 336: Maximix Arrangements]]
Given configurations of 11 carriages:
- Find the maximix arrangements (the worst possible arrangement if we sort ABC... in order)
- Compute the 2011th lexicographic arrangement

How can we sort the train most efficiently according to Simon's strategy? Given a string $s$ and some letter $l$ that we need to sort, there are only two options for sorting. Either $l$ is at the end of the string, then we immediately know that 1 reverse operation will yield the desired position. If $l$ is not at the end of the string, then we can cut the string in front of $l$, reverse the right substring, and then reverse the entire string. This needs 2 operations.

For example, consider 'beacd'. We would like to sort 'a' to the right position. Since a is not at the last index, we will split the string in two by splitting in front of the letter a: 'be' and 'acd'. Next, we reverse 'acd' to 'dca' and glue the substrings back to get 'bedca'. Finally, we reverse that string to obtain 'acdeb'. We can continue this for the remainder unsorted substring 'cdeb' to calculate the number of moves needed.

See code below for the sorting mechanism.
#+BEGIN_SRC python :results output :session p333
from itertools import permutations

N = 6

char2idx = {}
for c in range(0, N):
    char2idx[chr(ord('A')+c)] = c


idx2char = {}
for c in range(0, N):
    idx2char[c] = chr(ord('A')+c)


def reverse(s):
    return s[::-1]


def partial_sort(s, t):
    """Sort the string s.t. letter t will be in front."""
    if s[-1] == t:
        return 1, reverse(s)
    else:
        i = s.index(t)
        new_string = reverse(s[:i] + reverse(s[i:]))
        return 2, new_string
    return s


def sort(s, N):
    """Returns the number of moves needed to sorts train arrangement
    according to Simon's efficient ordering strategy."""
    count = 0
    for t in range(N):
        if s:
            if s[0] == idx2char[t]:
                s = s[1:]
            else:
                num_of_moves, new_s = partial_sort(s, idx2char[t])
                count += num_of_moves
                s = new_s[1:]
        else:
            break

    return count

def brute_force(K, target):
    """Brute-force all permutations of K strings and check maximix."""
    d = {}
    arrangements = permutations(char2idx.keys())
    for s in arrangements:
        d[s] = sort(s, K)

    maximix = sorted([k for k, v in d.items() if v == max(d.values())])
    # print(max(d.values()))
    import pprint
    # print(f'These are all arrangements for N = {N}: ')
    pprint.pprint(maximix)
    print(len(maximix))
    return maximix[target-1]

# print(sort('DFAECB', N))
print(brute_force(N, 0))


#N=4 / 5
#N=5 / 7
#N=6 / 9
#N=7 / 11
#N=8 / 13


#+END_SRC

#+RESULTS:
#+begin_example
[('C', 'A', 'D', 'E', 'B', 'F'),
 ('C', 'A', 'E', 'B', 'F', 'D'),
 ('C', 'D', 'A', 'E', 'B', 'F'),
 ('C', 'D', 'F', 'A', 'E', 'B'),
 ('C', 'D', 'F', 'B', 'A', 'E'),
 ('C', 'F', 'A', 'D', 'E', 'B'),
 ('C', 'F', 'B', 'A', 'D', 'E'),
 ('C', 'F', 'B', 'E', 'A', 'D'),
 ('D', 'A', 'E', 'C', 'B', 'F'),
 ('D', 'F', 'A', 'E', 'C', 'B'),
 ('D', 'F', 'B', 'A', 'E', 'C'),
 ('D', 'F', 'B', 'C', 'A', 'E'),
 ('E', 'A', 'D', 'B', 'F', 'C'),
 ('E', 'C', 'A', 'D', 'B', 'F'),
 ('E', 'C', 'F', 'A', 'D', 'B'),
 ('E', 'C', 'F', 'B', 'A', 'D'),
 ('F', 'A', 'D', 'E', 'C', 'B'),
 ('F', 'A', 'E', 'C', 'D', 'B'),
 ('F', 'B', 'A', 'D', 'E', 'C'),
 ('F', 'B', 'A', 'E', 'C', 'D'),
 ('F', 'B', 'C', 'A', 'D', 'E'),
 ('F', 'B', 'C', 'E', 'A', 'D'),
 ('F', 'B', 'D', 'A', 'E', 'C'),
 ('F', 'B', 'D', 'C', 'A', 'E')]
24
('F', 'B', 'D', 'C', 'A', 'E')
#+end_example

The only thing that remains is finding out how many configurations we need to consider. In total, there are $11!$ possible permutations of carriages, which is about $O(n^8)$ so we need to exclude some instances. Using the =brute_force= algorithm I computed the maximix value for each $N=4, \dots, 8$ which turns out to be =[5, 7, 9, 11, 13]=, so 2 steps for each increase in $N$. That means that for 11 trains, we will need 19 moves. If we consider the =partial_sort= algorithm, this would mean that in 9 cases we have a 'double' rotation and in 1 case we only need a single rotation. Since =sort= takes about ~60 microseconds, we can make at most ~1 million functions calls to remain in the 60 second solution threshold.

**** TODO How can we construct such bad arrangements? From the results above we can observe the following:
- 'A' is never followed by 'B' in a bad arrangement. Otherwise, this will give 'B' for free by the rotation step of 'A'.
- Doesn't start with 'A' or 'B'
- Never ends with 'A'

- 'F
- *How can I get good rotations*?
#+BEGIN_SRC
N = 4
[('D', 'A', 'C', 'B'),
 ('D', 'B', 'A', 'C')]

N = 5
: [('C', 'A', 'E', 'B', 'D'),
:  ('C', 'D', 'A', 'E', 'B'),
:  ('C', 'D', 'B', 'A', 'E'),
:  ('D', 'A', 'E', 'C', 'B'),
:  ('D', 'B', 'A', 'E', 'C'),
:  ('D', 'B', 'C', 'A', 'E')]

N = 6
[('C', 'A', 'D', 'E', 'B', 'F'),
 ('C', 'A', 'E', 'B', 'F', 'D'),
 ('C', 'D', 'A', 'E', 'B', 'F'),
 ('C', 'D', 'F', 'A', 'E', 'B'),
 ('C', 'D', 'F', 'B', 'A', 'E'),
 ('C', 'F', 'A', 'D', 'E', 'B'),
 ('C', 'F', 'B', 'A', 'D', 'E'),
 ('C', 'F', 'B', 'E', 'A', 'D'),
 ('D', 'A', 'E', 'C', 'B', 'F'),
 ('D', 'F', 'A', 'E', 'C', 'B'),
 ('D', 'F', 'B', 'A', 'E', 'C'),
 ('D', 'F', 'B', 'C', 'A', 'E'),
 ('E', 'A', 'D', 'B', 'F', 'C'),
 ('E', 'C', 'A', 'D', 'B', 'F'),
 ('E', 'C', 'F', 'A', 'D', 'B'),
 ('E', 'C', 'F', 'B', 'A', 'D'),
 ('F', 'A', 'D', 'E', 'C', 'B'),
 ('F', 'A', 'E', 'C', 'D', 'B'),
 ('F', 'B', 'A', 'D', 'E', 'C'),
 ('F', 'B', 'A', 'E', 'C', 'D'),
 ('F', 'B', 'C', 'A', 'D', 'E'),
 ('F', 'B', 'C', 'E', 'A', 'D'),
 ('F', 'B', 'D', 'A', 'E', 'C'),
 ('F', 'B', 'D', 'C', 'A', 'E')]
#+END_SRC

#+BEGIN_SRC python :results output :session p333


#+END_SRC

#+RESULTS:
: 6
: ('D', 'A', 'E', 'C', 'B')



** Techniques
*** Sieving
*** Dynamic programming
*** Discrete-time Markov Chains
Discrete-time Markov Chains can be easily solved using dynamic programming. The difficult part is to define a state representation whose transition probabilities can be defined relatively efficiently.

**** DONE Problem 151: Paper sheets of standard sizes: an expected-value problem
***** State representation
X(t) = State in binary representation at time t
P(X(0) = [1, 0, 0, 0, 0]) = 1
P(X(1) = [0, 1, 1, 1, 1]) = 1
P(X(2) = [0, 0, 2, 2, 2]) = 1/4
P(X(2) = [0, 1, 0, 2, 2]) = 1/4
P(X(2) = [0, 1, 1, 0, 1]) = 1/4
P(X(2) = [0, 1, 1, 1, 0]) = 1/4

P(X(t+1) = x | X(t) = y) = q

And so on.

***** State transitions
P(X(t+1) = x | X(t) = y) = q

Given a state, what are the next possible states? What are the probabilities? The next states can be computed by taking an sheet and cutting it in half until we have obtained an A5 sheet. The probability is equal to the total number of the chosen sheet divided the total number of sheets.

***** Example
Try an example of papers with sizes A3, A4 and A5.

***** Solution
Use the state representation. Calculate P(X(t) = x) for all possible x and t = 1, 2, ..., 16.

At t = 8, 12 and 14 we can expect to find a state with only 1 sheet (respectively a single A2, A3 or A4).

**** TODO Problem 213: Flea Circus
**** DONE Problem 227: The Chase
***** State representation
X(t) = The difference between player $i$ and $j$ at time $t$
***** Transition probabilities
Players i and j can perform 4 different move combinations:
- Both players stand still, so the difference remains the same
- Both players move into the same direction, so the difference remains the same
- Both players move into opposite directions, so the difference will be +- 2
- One player will move while the other will remain still, so the difference will be +- 1

For x = 2, ..., n-2:

P(X(t+1) = x) = P(X(t) = x-2) * 1/36 + P(X(t) = x-1) * 8/16 + P(X(t) = x) * 18/16 + P(X(t) = x+1) * 8/16 + P(X(t) = x+2) * 1/36

However, for x = 0, 1, n-1, n, we have to take into account the fact that we are working on a 'circle'. That is, from state 49 and moving into the same opposite will yield 49 + 2 = 51; but a difference of 51 is never possible in a game of 100 players. Instead, the difference will "rotate" around 50, so it will become 49 -> 50 -> 49.
***** Example
Try an example with 4 players and thus N = 2.

**** DONE Problem 280: Ant and seeds
***** State representation
For each state, we need to consider the following:
- The current position (i, j)
- The state of the lower row e.g. (1, 1, 1, 1, 1) if all seeds are still there
- The state of the upper row e.g. (0, 0, 0, 0, 0) if none of the seeds have been moved
- Whether or not the ant is currently carrying a seed or not

This state can be modeled as a 5-tuple (i, j, lower, upper, carrying). The number of possibilities of states is 5*5*32*32*2 = 51200; which can be easily computed.

***** Transition probabilities
The number of transitions for each state is limited; it is namely bounded by the moving option for each ant. An ant can only move up, down, left or right, and only if those moves are legible. So for each state, there are at most 4 different states to transition to. Calculating those transitions and its probabilities is easy (see Problem 213).

The more tricky part is how to take the lower, upper and carrying variables. We shall see that it only requires two conditions:
1. If the ant is currently carrying a seed, then it will only drop its seed if it moves to a new tile in the upper row that does not contain a seed.
2. If the ant is currently not carrying a seed, then it will only pick up a seed if it moves to a new tile in the lower row that does contain a seed.

If none of the conditions hold, then lower, upper and carrying all do not change.

***** Example
I won't include an example here because the instance size is fairly small.



**** [#A] Problem 285: Pythagorean odds

**** TODO Problem 323: Bitwise-OR operations on random integers

**** TODO Problem 329: Prime Frog
**** TODO Problem 493: Under The Rainbow
** Type of problems

#+BEGIN_SRC python :result output
def h():
    N = set()
    def f(x):
        if x == 0:
            N.add(1)
        elif x > 0:
            f(x-1)
    f(10)
    return N

print(h())
#+END_SRC

#+RESULTS:
: None
