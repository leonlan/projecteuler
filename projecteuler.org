#+PROPERTY: header-args :tangle yes :exports both

* Project Euler

** Solved problems

*** Problem 69: Totient maximum
Can be solved analytically. Otherwise, use a totient sieve.

*** Problem 70: Totient permutation
Use a totient sieve to solve this problem.

*** Problem 74: Digit factorial chains
This type of problem is solved using a cache, which keeps track of intermediate results. Without a cache, brute-forcing would be ridiculously expensive.

*** Problem 92: Square digit chains
This type of problem is best solved using a cache.b

*** [[https://projecteuler.net/problem=287][Problem 287: Quad-tree encoding (a simple compression algorithm)]] :recursion:
Let's first get a better understanding of the problem instance by visualizing the matrix for small $N$:
#+BEGIN_SRC python :results output
import numpy as np
from itertools import product


N = 3
A = np.zeros((2**N, 2**N))

def is_black(coord, N):
    x, y = coord
    return (x-2**(N-1))**2 + (y-2**(N-1))**2 <= 2**(2*N-2)

def is_white(coord, N):
    x, y = coord
    return not is_black(x, y, N)

for i, j in product(range(2**N), repeat=2):
    if is_black((i, j), N):
        A[2**N-j-1][i] = 1

print(A)
#+END_SRC

#+RESULTS:
: [[0. 0. 1. 1. 1. 1. 1. 0.]
:  [0. 1. 1. 1. 1. 1. 1. 1.]
:  [0. 1. 1. 1. 1. 1. 1. 1.]
:  [1. 1. 1. 1. 1. 1. 1. 1.]
:  [0. 1. 1. 1. 1. 1. 1. 1.]
:  [0. 1. 1. 1. 1. 1. 1. 1.]
:  [0. 0. 1. 1. 1. 1. 1. 0.]
:  [0. 0. 0. 0. 1. 0. 0. 0.]]

This kind of looks like a circle (of ones) in the middle. This makes our life much easier, because checking if a 'split' square is of 1 color can be done in checking the corners of the square (why?). Recursion is then feasible, because we can shortcut many subproblems and don't need to consider all $2^N$ possible subproblems.

My solution implements the following functions:
- =is_black(coord, N)= :: Checks if a given coordinate is black or not.
- =new_coords(coord, position, N)= :: Computes new coordinates for each subproblem.
- =same_color(coords, N)= :: Checks if the corners coordinates of a square all have the same color. Could be either white or black.
- =encode(coords, N, K)= :: Recursive computation of the length of the minimal encoding.

Without any optimizations, my algorithm took about 15 minutes to finish. I did some fiddling and managed to find the following optimizations to get it down to 4 minutes:
1. I sped-up =same_color= by 50% by summing the coordinate-colors (0 white, 1 black) and checking if it is either 0 (all white) or 4 (all black).
2. In =is_black=, I computed =2**(2N-2)= in every function call, but this is really expensive considering that this would be done for all coordinates. Instead, pre-computing this value decreased the speed by 33%.
3. In fact, using =math.pow= is much more efficient than =**= for some reason. This also increased my algorithm by about 50%.
4. In the discussion board people also talked about a symmetry (top left is rotational symmetric to right bottom) which could also speed up the code by 25%. I did not implement this.

As mentioned on the discussion board, it should be possible to get a pure python code to run in under 1 minute but it will require more optimizations. More specifically, computing =is_black= could be optimized much further (for example, a pre-computed table for (x, y) values for which the coordinates are guaranteed to be black).

*** [[https://projecteuler.net/problem=265][Problem 265: Binary circles]] :recursion:
Problem understanding
- Start with [0]*N.
- What are the possible binary circle representations?
- Each subsequence in 2*N must appear exactly once.

If I extend my current substring, then I can only append 0 or 1. That means that the total possible number of substrings I can make is O(2^(2^N)). Luckily, we don't need to compute them all. Here is a code that I wrote really quick:

#+BEGIN_SRC python :results output
def is_substring(s, substring):
    return substring in s

def check(s, N):
    S = set()
    s = s + s[:N-1]
    return len(set([s[i:i+N] for i in range(2**N)])) == 2**N

L = []

def extend(seq, tail, N):
    if len(seq) == 2**N:
        if check(seq, N):
            L.append(seq)
    else:
        for i in range(2):
            candidate = tail[1:] + f'{i}'
            if not is_substring(seq, candidate):
                extend(seq + f'{i}', candidate, N)

extend('000', '000', 3)
print(L)
#+end_src

#+RESULTS:
: ['00010111', '00011101']

Surprisingly, it turns out that this also works fine for $N=5$. It even terminates within 1 second. The =check= procedure might be a bit expensive, but there aren't many 32-bit candidates that we need to check, so it is not a big issue.

** Work in progress

*** [[https://projecteuler.net/problem=300][Problem 300: Protein folding]]
Problem:
- Suppose you have a random H-P string of size 2**N
- What is the expected number of H-H contact points?

Thoughts
- 0 H => 0 points
- 1 H => 0 points
- 2 H => 1 point or 0 point
  For example, HPH can never have a point connected.
  But HHP can always get a point connected

Steps:
- Suppose
- Find the optimal string(s)
- Compute all possibilities of H/P element placements
- Calculate the H-H contact points, sum them up

**** TODO How many optimal foldings exist?

**** TODO

** Techniques
*** Sieving
*** Dynamic programming
*** Discrete-time Markov Chains
Discrete-time Markov Chains can be easily solved using dynamic programming. The difficult part is to define a state representation whose transition probabilities can be defined relatively efficiently.

**** DONE Problem 151: Paper sheets of standard sizes: an expected-value problem
***** State representation
X(t) = State in binary representation at time t
P(X(0) = [1, 0, 0, 0, 0]) = 1
P(X(1) = [0, 1, 1, 1, 1]) = 1
P(X(2) = [0, 0, 2, 2, 2]) = 1/4
P(X(2) = [0, 1, 0, 2, 2]) = 1/4
P(X(2) = [0, 1, 1, 0, 1]) = 1/4
P(X(2) = [0, 1, 1, 1, 0]) = 1/4

P(X(t+1) = x | X(t) = y) = q

And so on.

***** State transitions
P(X(t+1) = x | X(t) = y) = q

Given a state, what are the next possible states? What are the probabilities? The next states can be computed by taking an sheet and cutting it in half until we have obtained an A5 sheet. The probability is equal to the total number of the chosen sheet divided the total number of sheets.

***** Example
Try an example of papers with sizes A3, A4 and A5.

***** Solution
Use the state representation. Calculate P(X(t) = x) for all possible x and t = 1, 2, ..., 16.

At t = 8, 12 and 14 we can expect to find a state with only 1 sheet (respectively a single A2, A3 or A4).

**** TODO Problem 213: Flea Circus
**** DONE Problem 227: The Chase
***** State representation
X(t) = The difference between player $i$ and $j$ at time $t$
***** Transition probabilities
Players i and j can perform 4 different move combinations:
- Both players stand still, so the difference remains the same
- Both players move into the same direction, so the difference remains the same
- Both players move into opposite directions, so the difference will be +- 2
- One player will move while the other will remain still, so the difference will be +- 1

For x = 2, ..., n-2:

P(X(t+1) = x) = P(X(t) = x-2) * 1/36 + P(X(t) = x-1) * 8/16 + P(X(t) = x) * 18/16 + P(X(t) = x+1) * 8/16 + P(X(t) = x+2) * 1/36

However, for x = 0, 1, n-1, n, we have to take into account the fact that we are working on a 'circle'. That is, from state 49 and moving into the same opposite will yield 49 + 2 = 51; but a difference of 51 is never possible in a game of 100 players. Instead, the difference will "rotate" around 50, so it will become 49 -> 50 -> 49.
***** Example
Try an example with 4 players and thus N = 2.

**** DONE Problem 280: Ant and seeds
***** State representation
For each state, we need to consider the following:
- The current position (i, j)
- The state of the lower row e.g. (1, 1, 1, 1, 1) if all seeds are still there
- The state of the upper row e.g. (0, 0, 0, 0, 0) if none of the seeds have been moved
- Whether or not the ant is currently carrying a seed or not

This state can be modeled as a 5-tuple (i, j, lower, upper, carrying). The number of possibilities of states is 5*5*32*32*2 = 51200; which can be easily computed.

***** Transition probabilities
The number of transitions for each state is limited; it is namely bounded by the moving option for each ant. An ant can only move up, down, left or right, and only if those moves are legible. So for each state, there are at most 4 different states to transition to. Calculating those transitions and its probabilities is easy (see Problem 213).

The more tricky part is how to take the lower, upper and carrying variables. We shall see that it only requires two conditions:
1. If the ant is currently carrying a seed, then it will only drop its seed if it moves to a new tile in the upper row that does not contain a seed.
2. If the ant is currently not carrying a seed, then it will only pick up a seed if it moves to a new tile in the lower row that does contain a seed.

If none of the conditions hold, then lower, upper and carrying all do not change.

***** Example
I won't include an example here because the instance size is fairly small.



**** [#A] Problem 285: Pythagorean odds

**** TODO Problem 323: Bitwise-OR operations on random integers

**** TODO Problem 329: Prime Frog
**** TODO Problem 493: Under The Rainbow
** Type of problems
